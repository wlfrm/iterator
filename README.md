/**
 * @desc <pre>
 * Класс итератор, для модификации существующего итератора/массива на лету
 * ИЛИ для внедрения собственной логики в циклическую обработку массивов (расширение логики цикла)
 * позволяет навесить callback-функции на момент прохода в цике на возвращающиеся ключи и значения
 *
 * Рекомендуется пользоваться фабричным методом-хэлпером CLib_Iterator_Map::create() для более простого создания данного итератора
 * При сложностях в использовании класса рекомендуется ознакомится с типом callback @see http://www.php.net/manual/ru/language.types.callable.php
 *
 * Ограничения и правила для callback-функций:
 * 1. Сигнатуры callback методов для значений должны быть следующего вида:
 *		function($value){...}
 * а для ключей следующего:
 *		function($key){...}
 *
 * 2. Есть возможность передачи ключей или значений в качестве дополнительного параметра в любой из определённых callback,
 * для этого необходимо использовать специальные методы-сеттеры setValueCallablePassKeys() и setKeyCallablePassValues()
 * В этом случае сигнатуры callback-функций должны иметь иной вид:
 *		function($value, $key){...} - для значений, если был вызван setValueCallablePassKeys()
 *		function($key, $value){...} - для ключей, если был вызван setKeyCallablePassValues()
 *
 * 3. Есть возможность передачи дополнительных "внешних" аргументов в функции-замыкания,
 * данные аргументы будут передаватся в нужный callback на каждой итерации. Для этого используются следующие методы-сеттеры:
 * setValueArgs($arg1, $arg2, ..., $argN)
 * setKeyArgs($arg1, $arg2, ..., $argN)
 * В этом случае сигнатуры callback-функций должны иметь следующий вид:
 *		function($value, $arg1, $arg2, ..., $argN){...} - для значений, если был вызван setValueArgs($arg1, $arg2, ..., $argN)
 *		function($key, $arg1, $arg2, ..., $argN){...} - для ключей, если был вызван setKeyArgs($arg1, $arg2, ..., $argN)
 *
 * 4. Оба способа передачи аргументов для callback (2 и 3) друг друга дополняют, возможно их произвольное смешивание/комбинирование:
 * В этом случае сигнатуры callback-функций должны иметь такой вид:
 *  для значений, если были вызваны
 *		$iterator->setValueArgs($arg1, $arg2, ..., $argN)->setValueCallablePassKeys();
 *  ожидается такой callback:
 *		function($value, $key, $arg1, $arg2, ..., $argN){...}
 *
 *  для ключей, если были вызваны
 *		$iterator->setKeyArgs($arg1, $arg2, ..., $argN)->setKeyCallablePassValues();
 *  ожидается такой callback:
 *		function($key, $value, $arg1, $arg2, ..., $argN){...}
 *
 *
 * 5. Callback метод для значений может возвращать любые значения.
 *
 * 6. Callback метод для ключей должен возвращать скалярные или NULL значения для корректной работы
 * иначе будет выброшено исключение RuntimeException
 * Это связано с потенциальным использованием SPL-функции iterator_to_array()
 * подробности данного ограничения можно почитать тут: @see http://md1.php.net/manual/ru/language.types.array.php
 *
 * 7. Сигнатуры callback должны соответствовать количеству обязательных передаваемых аргументов.
 * В ином случае будет выброшено InvalidArgumentException
 *
 * 8. Типы значений callback-аргументов проверяются во время выполнения, типы должны соответствовать указанным типам в сигнатуре callback
 * в случае расхождения будет выброшено соответствующее php-исключение или сгенерирована ошибка.
 *
 * 9. Хотя бы один callback должен быть установлен: или для ключей или для значений или для обоих.
 * Иначе использование класса не имеет смысла и получите CLib_Exception_BadUsage
 *